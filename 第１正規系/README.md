# 第１正規系
実は、リレーショナルデータベースのテーブルはいずれもすでに、第１正規系を満たす形になっている。
第１正規系の定義とは、「一つのテーブルの中に、一つの値しか含まないこと」というものである。

一つの値だけ含まれている値のことを「スカラ値（scalar value）」と呼びます。scalarは「単一の」という意味の英単語です。

リレーショナルデータベースは、必ず第１正規系を満たすテーブルだけから作られなければならないのです。これを関数中属性(function dependency)と呼びます。
X=5と定めれが、Y=10のように、Xに対してYが一つだけ決まリます。これを「YはXに従属する」と表現します。

+--------+-------+-----------+
| name   | score | result    |
+--------+-------+-----------+
| 鈴木   |    92 | 合格      |
| 佐藤   |    74 | 合格      |
| 山田   |    43 | 不合格    |
| 田中   |    65 | 合格      |
| 中村   |    80 | 合格      |
| 小林   |    58 | 不合格    |
+--------+-------+-----------+# 第１正規系
SQLの第１正規系とは、データベースのテーブルの中に、重複したデータがないことを指す。
例えば、生徒の名前と点数しかないテーブルがあったとする。
このテーブルは、第１正規系に違反している。
なぜなら、生徒の名前が重複しているからである。
このテーブルを第１正規系にするには、生徒の名前を主キーにする必要がある。


## 部結合
INNER JOINは、結合条件に合致するレコードのみを取得する。

```
+-------------+---------------+--------------+
| employee_id | employee_name | child_name   |
+-------------+---------------+--------------+
| 0001        | 山田太郎      | 山田花子     |
| 0001        | 山田太郎      | 山田次郎     |
| 0002        | 鈴木一郎      | 鈴木花子     |
| 0002        | 鈴木一郎      | 鈴木次郎     |
| 0003        | 佐藤花子      | 佐藤花子     |
| 0003        | 佐藤花子      | 佐藤次郎     |
| 0003        | 佐藤花子      | 佐藤三郎     |
| 0004        | 田中次郎      | 田中花子     |
| 0004        | 田中次郎      | 田中次郎     |
| 0004        | 田中次郎      | 田中三郎     |
+-------------+---------------+--------------+
```

## 外部結合
OUTER JOINは、結合条件に合致しないレコードも取得する。

```
+-------------+---------------+--------------+
| employee_id | employee_name | child_name   |
+-------------+---------------+--------------+
| 0001        | 山田太郎      | 山田次郎     |
| 0001        | 山田太郎      | 山田花子     |
| 0002        | 鈴木一郎      | 鈴木次郎     |
| 0002        | 鈴木一郎      | 鈴木花子     |
| 0003        | 佐藤花子      | 佐藤三郎     |
| 0003        | 佐藤花子      | 佐藤次郎     |
| 0003        | 佐藤花子      | 佐藤花子     |
| 0004        | 田中次郎      | 田中三郎     |
| 0004        | 田中次郎      | 田中次郎     |
| 0004        | 田中次郎      | 田中花子     |
| 0005        | 山本三郎      | NULL         |
+-------------+---------------+--------------+
```

## 仮想のテーブルを作成する
Viewとは、仮想のテーブルを作成することができる機能である。
クエリを実行するときに、Viewを参照することで、テーブルを作成することなく、テーブルのように扱うことができる。
クエリを指定することで、Viewを作成することができる。
```
mysql> CREATE VIEW employee_view AS SELECT * FROM employee;
-- employee_viewに対して、viewを実行するsql --
SELECT * FROM employee_view;Query OK, 0 rows affected (0.02 sec)

mysql> -- employee_viewに対して、viewを実行するsql --
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM employee_view;
+----+-------------+---------------+
| id | employee_id | employee_name |
+----+-------------+---------------+
|  1 | 0001        | 山田太郎      |
|  2 | 0002        | 鈴木一郎      |
|  3 | 0003        | 佐藤花子      |
|  4 | 0004        | 田中次郎      |
|  5 | 0005        | 山本三郎      |
+----+-------------+---------------+
5 rows in set (0.01 sec)
```

## window関数
window関数は、集計関数を使って、集計を行うことができる。
例えば、生徒の名前と点数しかないテーブルから、生徒の名前と点数、その生徒の平均点を取得することができる。
```sql
SELECT
    name,
    score,
    AVG(score) OVER() AS avg_score
FROM
    student;
```

sql文の解説をすると、
```sql
SELECT カラム名1, カラム名2, 集計関数 OVER() AS 集計関数名 FROM テーブル名;
```

SELECTの後に、カラム名を指定することで、そのカラムの値を取得することができる。
集計関数は、SUM, AVG, MAX, MIN, COUNTがある。
OVER()の中には、PARTITION BY カラム名を指定することで、そのカラムでグループ分けを行うことができる。

実行結果
```
mysql> SELECT
    ->     name,
    ->     score,
    ->     RANK() OVER(ORDER BY score DESC) AS `rank`
    -> FROM
    ->     student_score
    -> ORDER BY
    ->     `rank`;
+--------+-------+------+
| name   | score | rank |
+--------+-------+------+
| 鈴木   |    92 |    1 |
| 中村   |    80 |    2 |
| 佐藤   |    74 |    3 |
| 田中   |    65 |    4 |
| 小林   |    58 |    5 |
| 山田   |    43 |    6 |
+--------+-------+------+
```

## IFを使う
IFを使うことで、条件によって、値を変えることができる。
```sql
SELECT
    name,
    score,
    IF(score >= 60, '合格', '不合格') AS result
FROM
    student_score;
```

実行結果
```

```

## CASEを使う
複数の条件によって、値を変えることができる。

```sql
SELECT
    name,
    score,
    CASE
        WHEN score >= 80 THEN '優'
        WHEN score >= 60 THEN '良'
        WHEN score >= 40 THEN '可'
        ELSE '不可'
    END AS result
FROM
    student_score;
```